// Code generated by genny DO NOT EDIT.

package set

import "fmt"

// Float32Set implements the set data structure implemented with a map. The set
// has an optional capacity. By default, this cap is set to zero. Setting a
//positive cap will cause silent failures whenever trying to add elements to a
// full set.
type Float32Set struct {
	vals map[float32]bool
	cap  int
}

// NewFloat32Set creates a new set of float32 values.
func NewFloat32Set(vals ...float32) *Float32Set {
	s := Float32Set{vals: map[float32]bool{}}
	for _, v := range vals {
		s.vals[v] = true
	}
	return &s
}

func (s *Float32Set) String() string {
	return fmt.Sprintf("%v", s.Enumerate())
}

// Contains checks if the provided value is in the set.
func (s *Float32Set) Contains(val float32) bool {
	return s.vals[val]
}

// IsSubset checks if the set is a subset of b i,e, every element of the set s
// is contained in b.
func (s *Float32Set) IsSubset(b Float32Set) bool {
	if len(s.vals) > len(b.vals) {
		return false
	}

	for k := range s.vals {
		if !b.vals[k] {
			return false
		}
	}

	return true
}

// IsEmpty checks of the set does not contain any elements.
func (s *Float32Set) IsEmpty() bool {
	return len(s.vals) == 0
}

// Len returns the number of elements in the set.
func (s *Float32Set) Len() int {
	return len(s.vals)
}

// Cap returns the capacity of the set.
func (s *Float32Set) Cap() int {
	return s.cap
}

// SetCap sets the capacity of the set. If a negative integer is passed, then
// the capacity is set to 0. A capacity of 0 indicates no capacity.
func (s *Float32Set) SetCap(c int) *Float32Set {
	if c < 0 {
		c = 0
	}

	s.cap = c
	return s
}

// Enumerate returns a slice of the elements in the set that can be used in a
// for ... range loop. Depending on what the data is being used for, consider
// using the Map, Filter, and Fold methods instead as they act on the set
// itself.
func (s *Float32Set) Enumerate() []float32 {
	keys := make([]float32, len(s.vals))
	i := 0
	for k := range s.vals {
		keys[i] = k
		i++
	}
	return keys
}

// Add adds the provided val to the set. If the set has already reached
// capacity, then the addition silently fails.
func (s *Float32Set) Add(val float32) *Float32Set {
	if s.cap > 0 && len(s.vals) == s.cap {
		return s
	}

	s.vals[val] = true
	return s
}

// Remove deletes the provided values from the set. If the value is not in the
// set, then this is a no-op.
func (s *Float32Set) Remove(val float32) *Float32Set {
	delete(s.vals, val)
	return s
}

// Clear removes all elements from the set. This does not clear the capcity.
func (s *Float32Set) Clear() *Float32Set {
	for k := range s.vals {
		delete(s.vals, k)
	}
	return s
}

// Equals checks if the provided set is equal to this set. Sets A and B are
// equal if A is a subset of B and B is a subset of A.
func (s *Float32Set) Equals(s2 Float32Set) bool {
	if len(s.vals) != len(s2.vals) {
		return false
	}

	return s.IsSubset(s2)
}

// Map applies the provided function to every element in the set. Because the
// set must only contain unique elements, the size of the set may change
// after applying the transformation function.
func (s *Float32Set) Map(f func(float32) float32) *Float32Set {
	out := NewFloat32Set().SetCap(s.cap)
	for k := range s.vals {
		out.vals[f(k)] = true
	}
	return out
}

// Filter applies the provided function to every element in the set. The
// resulting set contains only the elements that caused the function to
// return true.
func (s *Float32Set) Filter(f func(float32) bool) *Float32Set {
	out := NewFloat32Set().SetCap(s.cap)
	for k := range s.vals {
		if f(k) {
			out.vals[k] = true
		}
	}
	return out
}

// Fold reduces the set to a single value by successively applying the provided
// function to elements of the set beginning with the base. The operation
// performed in the provided function must be associative and communitive to
// guarantee a deterministic result.
func (s *Float32Set) Fold(base float32, f func(float32, float32) float32) float32 {
	for k := range s.vals {
		base = f(base, k)
	}
	return base
}

// Union returns the union of this set with the provided set. The union of two
// sets A and B is defined by:
//	A union B = {x | (x in A) or (x in B)}
func (s *Float32Set) Union(s2 Float32Set) *Float32Set {
	out := NewFloat32Set()

	for k := range s.vals {
		out.vals[k] = true
	}

	for k := range s2.vals {
		out.vals[k] = true
	}

	return out
}

// Intersect returns the intersection of this set with the provided set. The
// intersection of two sets A and B is defined by:
//	A intersect B = {x | (x in A) and (x in B)}
func (s *Float32Set) Intersect(s2 Float32Set) *Float32Set {
	out := NewFloat32Set()

	for k := range s.vals {
		if s2.vals[k] {
			out.vals[k] = true
		}
	}

	for k := range s2.vals {
		if s.vals[k] {
			out.vals[k] = true
		}
	}

	return out
}

// Diff returns the set difference of this set with the provided set. The
// set difference of two sets A and B is defined as:
//	A \ B = {x | (x in A) and (x not in B)}
func (s *Float32Set) Diff(s2 Float32Set) *Float32Set {
	out := NewFloat32Set()

	for k := range s.vals {
		if !s2.vals[k] {
			out.vals[k] = true
		}
	}

	return out
}

// SymDiff returns the symmetric difference of this set with the provided set.
// The symmetric difference of two sets A and B is defined as:
//	A (+) B = {x | (x in A) xor (x in B)}
func (s *Float32Set) SymDiff(s2 Float32Set) *Float32Set {
	out := NewFloat32Set()

	for k := range s.vals {
		if !s2.vals[k] {
			out.vals[k] = true
		}
	}

	for k := range s2.vals {
		if !s.vals[k] {
			out.vals[k] = true
		}
	}

	return out
}

// Float64Set implements the set data structure implemented with a map. The set
// has an optional capacity. By default, this cap is set to zero. Setting a
//positive cap will cause silent failures whenever trying to add elements to a
// full set.
type Float64Set struct {
	vals map[float64]bool
	cap  int
}

// NewFloat64Set creates a new set of float64 values.
func NewFloat64Set(vals ...float64) *Float64Set {
	s := Float64Set{vals: map[float64]bool{}}
	for _, v := range vals {
		s.vals[v] = true
	}
	return &s
}

func (s *Float64Set) String() string {
	return fmt.Sprintf("%v", s.Enumerate())
}

// Contains checks if the provided value is in the set.
func (s *Float64Set) Contains(val float64) bool {
	return s.vals[val]
}

// IsSubset checks if the set is a subset of b i,e, every element of the set s
// is contained in b.
func (s *Float64Set) IsSubset(b Float64Set) bool {
	if len(s.vals) > len(b.vals) {
		return false
	}

	for k := range s.vals {
		if !b.vals[k] {
			return false
		}
	}

	return true
}

// IsEmpty checks of the set does not contain any elements.
func (s *Float64Set) IsEmpty() bool {
	return len(s.vals) == 0
}

// Len returns the number of elements in the set.
func (s *Float64Set) Len() int {
	return len(s.vals)
}

// Cap returns the capacity of the set.
func (s *Float64Set) Cap() int {
	return s.cap
}

// SetCap sets the capacity of the set. If a negative integer is passed, then
// the capacity is set to 0. A capacity of 0 indicates no capacity.
func (s *Float64Set) SetCap(c int) *Float64Set {
	if c < 0 {
		c = 0
	}

	s.cap = c
	return s
}

// Enumerate returns a slice of the elements in the set that can be used in a
// for ... range loop. Depending on what the data is being used for, consider
// using the Map, Filter, and Fold methods instead as they act on the set
// itself.
func (s *Float64Set) Enumerate() []float64 {
	keys := make([]float64, len(s.vals))
	i := 0
	for k := range s.vals {
		keys[i] = k
		i++
	}
	return keys
}

// Add adds the provided val to the set. If the set has already reached
// capacity, then the addition silently fails.
func (s *Float64Set) Add(val float64) *Float64Set {
	if s.cap > 0 && len(s.vals) == s.cap {
		return s
	}

	s.vals[val] = true
	return s
}

// Remove deletes the provided values from the set. If the value is not in the
// set, then this is a no-op.
func (s *Float64Set) Remove(val float64) *Float64Set {
	delete(s.vals, val)
	return s
}

// Clear removes all elements from the set. This does not clear the capcity.
func (s *Float64Set) Clear() *Float64Set {
	for k := range s.vals {
		delete(s.vals, k)
	}
	return s
}

// Equals checks if the provided set is equal to this set. Sets A and B are
// equal if A is a subset of B and B is a subset of A.
func (s *Float64Set) Equals(s2 Float64Set) bool {
	if len(s.vals) != len(s2.vals) {
		return false
	}

	return s.IsSubset(s2)
}

// Map applies the provided function to every element in the set. Because the
// set must only contain unique elements, the size of the set may change
// after applying the transformation function.
func (s *Float64Set) Map(f func(float64) float64) *Float64Set {
	out := NewFloat64Set().SetCap(s.cap)
	for k := range s.vals {
		out.vals[f(k)] = true
	}
	return out
}

// Filter applies the provided function to every element in the set. The
// resulting set contains only the elements that caused the function to
// return true.
func (s *Float64Set) Filter(f func(float64) bool) *Float64Set {
	out := NewFloat64Set().SetCap(s.cap)
	for k := range s.vals {
		if f(k) {
			out.vals[k] = true
		}
	}
	return out
}

// Fold reduces the set to a single value by successively applying the provided
// function to elements of the set beginning with the base. The operation
// performed in the provided function must be associative and communitive to
// guarantee a deterministic result.
func (s *Float64Set) Fold(base float64, f func(float64, float64) float64) float64 {
	for k := range s.vals {
		base = f(base, k)
	}
	return base
}

// Union returns the union of this set with the provided set. The union of two
// sets A and B is defined by:
//	A union B = {x | (x in A) or (x in B)}
func (s *Float64Set) Union(s2 Float64Set) *Float64Set {
	out := NewFloat64Set()

	for k := range s.vals {
		out.vals[k] = true
	}

	for k := range s2.vals {
		out.vals[k] = true
	}

	return out
}

// Intersect returns the intersection of this set with the provided set. The
// intersection of two sets A and B is defined by:
//	A intersect B = {x | (x in A) and (x in B)}
func (s *Float64Set) Intersect(s2 Float64Set) *Float64Set {
	out := NewFloat64Set()

	for k := range s.vals {
		if s2.vals[k] {
			out.vals[k] = true
		}
	}

	for k := range s2.vals {
		if s.vals[k] {
			out.vals[k] = true
		}
	}

	return out
}

// Diff returns the set difference of this set with the provided set. The
// set difference of two sets A and B is defined as:
//	A \ B = {x | (x in A) and (x not in B)}
func (s *Float64Set) Diff(s2 Float64Set) *Float64Set {
	out := NewFloat64Set()

	for k := range s.vals {
		if !s2.vals[k] {
			out.vals[k] = true
		}
	}

	return out
}

// SymDiff returns the symmetric difference of this set with the provided set.
// The symmetric difference of two sets A and B is defined as:
//	A (+) B = {x | (x in A) xor (x in B)}
func (s *Float64Set) SymDiff(s2 Float64Set) *Float64Set {
	out := NewFloat64Set()

	for k := range s.vals {
		if !s2.vals[k] {
			out.vals[k] = true
		}
	}

	for k := range s2.vals {
		if !s.vals[k] {
			out.vals[k] = true
		}
	}

	return out
}

// IntSet implements the set data structure implemented with a map. The set
// has an optional capacity. By default, this cap is set to zero. Setting a
//positive cap will cause silent failures whenever trying to add elements to a
// full set.
type IntSet struct {
	vals map[int]bool
	cap  int
}

// NewIntSet creates a new set of int values.
func NewIntSet(vals ...int) *IntSet {
	s := IntSet{vals: map[int]bool{}}
	for _, v := range vals {
		s.vals[v] = true
	}
	return &s
}

func (s *IntSet) String() string {
	return fmt.Sprintf("%v", s.Enumerate())
}

// Contains checks if the provided value is in the set.
func (s *IntSet) Contains(val int) bool {
	return s.vals[val]
}

// IsSubset checks if the set is a subset of b i,e, every element of the set s
// is contained in b.
func (s *IntSet) IsSubset(b IntSet) bool {
	if len(s.vals) > len(b.vals) {
		return false
	}

	for k := range s.vals {
		if !b.vals[k] {
			return false
		}
	}

	return true
}

// IsEmpty checks of the set does not contain any elements.
func (s *IntSet) IsEmpty() bool {
	return len(s.vals) == 0
}

// Len returns the number of elements in the set.
func (s *IntSet) Len() int {
	return len(s.vals)
}

// Cap returns the capacity of the set.
func (s *IntSet) Cap() int {
	return s.cap
}

// SetCap sets the capacity of the set. If a negative integer is passed, then
// the capacity is set to 0. A capacity of 0 indicates no capacity.
func (s *IntSet) SetCap(c int) *IntSet {
	if c < 0 {
		c = 0
	}

	s.cap = c
	return s
}

// Enumerate returns a slice of the elements in the set that can be used in a
// for ... range loop. Depending on what the data is being used for, consider
// using the Map, Filter, and Fold methods instead as they act on the set
// itself.
func (s *IntSet) Enumerate() []int {
	keys := make([]int, len(s.vals))
	i := 0
	for k := range s.vals {
		keys[i] = k
		i++
	}
	return keys
}

// Add adds the provided val to the set. If the set has already reached
// capacity, then the addition silently fails.
func (s *IntSet) Add(val int) *IntSet {
	if s.cap > 0 && len(s.vals) == s.cap {
		return s
	}

	s.vals[val] = true
	return s
}

// Remove deletes the provided values from the set. If the value is not in the
// set, then this is a no-op.
func (s *IntSet) Remove(val int) *IntSet {
	delete(s.vals, val)
	return s
}

// Clear removes all elements from the set. This does not clear the capcity.
func (s *IntSet) Clear() *IntSet {
	for k := range s.vals {
		delete(s.vals, k)
	}
	return s
}

// Equals checks if the provided set is equal to this set. Sets A and B are
// equal if A is a subset of B and B is a subset of A.
func (s *IntSet) Equals(s2 IntSet) bool {
	if len(s.vals) != len(s2.vals) {
		return false
	}

	return s.IsSubset(s2)
}

// Map applies the provided function to every element in the set. Because the
// set must only contain unique elements, the size of the set may change
// after applying the transformation function.
func (s *IntSet) Map(f func(int) int) *IntSet {
	out := NewIntSet().SetCap(s.cap)
	for k := range s.vals {
		out.vals[f(k)] = true
	}
	return out
}

// Filter applies the provided function to every element in the set. The
// resulting set contains only the elements that caused the function to
// return true.
func (s *IntSet) Filter(f func(int) bool) *IntSet {
	out := NewIntSet().SetCap(s.cap)
	for k := range s.vals {
		if f(k) {
			out.vals[k] = true
		}
	}
	return out
}

// Fold reduces the set to a single value by successively applying the provided
// function to elements of the set beginning with the base. The operation
// performed in the provided function must be associative and communitive to
// guarantee a deterministic result.
func (s *IntSet) Fold(base int, f func(int, int) int) int {
	for k := range s.vals {
		base = f(base, k)
	}
	return base
}

// Union returns the union of this set with the provided set. The union of two
// sets A and B is defined by:
//	A union B = {x | (x in A) or (x in B)}
func (s *IntSet) Union(s2 IntSet) *IntSet {
	out := NewIntSet()

	for k := range s.vals {
		out.vals[k] = true
	}

	for k := range s2.vals {
		out.vals[k] = true
	}

	return out
}

// Intersect returns the intersection of this set with the provided set. The
// intersection of two sets A and B is defined by:
//	A intersect B = {x | (x in A) and (x in B)}
func (s *IntSet) Intersect(s2 IntSet) *IntSet {
	out := NewIntSet()

	for k := range s.vals {
		if s2.vals[k] {
			out.vals[k] = true
		}
	}

	for k := range s2.vals {
		if s.vals[k] {
			out.vals[k] = true
		}
	}

	return out
}

// Diff returns the set difference of this set with the provided set. The
// set difference of two sets A and B is defined as:
//	A \ B = {x | (x in A) and (x not in B)}
func (s *IntSet) Diff(s2 IntSet) *IntSet {
	out := NewIntSet()

	for k := range s.vals {
		if !s2.vals[k] {
			out.vals[k] = true
		}
	}

	return out
}

// SymDiff returns the symmetric difference of this set with the provided set.
// The symmetric difference of two sets A and B is defined as:
//	A (+) B = {x | (x in A) xor (x in B)}
func (s *IntSet) SymDiff(s2 IntSet) *IntSet {
	out := NewIntSet()

	for k := range s.vals {
		if !s2.vals[k] {
			out.vals[k] = true
		}
	}

	for k := range s2.vals {
		if !s.vals[k] {
			out.vals[k] = true
		}
	}

	return out
}

// Int16Set implements the set data structure implemented with a map. The set
// has an optional capacity. By default, this cap is set to zero. Setting a
//positive cap will cause silent failures whenever trying to add elements to a
// full set.
type Int16Set struct {
	vals map[int16]bool
	cap  int
}

// NewInt16Set creates a new set of int16 values.
func NewInt16Set(vals ...int16) *Int16Set {
	s := Int16Set{vals: map[int16]bool{}}
	for _, v := range vals {
		s.vals[v] = true
	}
	return &s
}

func (s *Int16Set) String() string {
	return fmt.Sprintf("%v", s.Enumerate())
}

// Contains checks if the provided value is in the set.
func (s *Int16Set) Contains(val int16) bool {
	return s.vals[val]
}

// IsSubset checks if the set is a subset of b i,e, every element of the set s
// is contained in b.
func (s *Int16Set) IsSubset(b Int16Set) bool {
	if len(s.vals) > len(b.vals) {
		return false
	}

	for k := range s.vals {
		if !b.vals[k] {
			return false
		}
	}

	return true
}

// IsEmpty checks of the set does not contain any elements.
func (s *Int16Set) IsEmpty() bool {
	return len(s.vals) == 0
}

// Len returns the number of elements in the set.
func (s *Int16Set) Len() int {
	return len(s.vals)
}

// Cap returns the capacity of the set.
func (s *Int16Set) Cap() int {
	return s.cap
}

// SetCap sets the capacity of the set. If a negative integer is passed, then
// the capacity is set to 0. A capacity of 0 indicates no capacity.
func (s *Int16Set) SetCap(c int) *Int16Set {
	if c < 0 {
		c = 0
	}

	s.cap = c
	return s
}

// Enumerate returns a slice of the elements in the set that can be used in a
// for ... range loop. Depending on what the data is being used for, consider
// using the Map, Filter, and Fold methods instead as they act on the set
// itself.
func (s *Int16Set) Enumerate() []int16 {
	keys := make([]int16, len(s.vals))
	i := 0
	for k := range s.vals {
		keys[i] = k
		i++
	}
	return keys
}

// Add adds the provided val to the set. If the set has already reached
// capacity, then the addition silently fails.
func (s *Int16Set) Add(val int16) *Int16Set {
	if s.cap > 0 && len(s.vals) == s.cap {
		return s
	}

	s.vals[val] = true
	return s
}

// Remove deletes the provided values from the set. If the value is not in the
// set, then this is a no-op.
func (s *Int16Set) Remove(val int16) *Int16Set {
	delete(s.vals, val)
	return s
}

// Clear removes all elements from the set. This does not clear the capcity.
func (s *Int16Set) Clear() *Int16Set {
	for k := range s.vals {
		delete(s.vals, k)
	}
	return s
}

// Equals checks if the provided set is equal to this set. Sets A and B are
// equal if A is a subset of B and B is a subset of A.
func (s *Int16Set) Equals(s2 Int16Set) bool {
	if len(s.vals) != len(s2.vals) {
		return false
	}

	return s.IsSubset(s2)
}

// Map applies the provided function to every element in the set. Because the
// set must only contain unique elements, the size of the set may change
// after applying the transformation function.
func (s *Int16Set) Map(f func(int16) int16) *Int16Set {
	out := NewInt16Set().SetCap(s.cap)
	for k := range s.vals {
		out.vals[f(k)] = true
	}
	return out
}

// Filter applies the provided function to every element in the set. The
// resulting set contains only the elements that caused the function to
// return true.
func (s *Int16Set) Filter(f func(int16) bool) *Int16Set {
	out := NewInt16Set().SetCap(s.cap)
	for k := range s.vals {
		if f(k) {
			out.vals[k] = true
		}
	}
	return out
}

// Fold reduces the set to a single value by successively applying the provided
// function to elements of the set beginning with the base. The operation
// performed in the provided function must be associative and communitive to
// guarantee a deterministic result.
func (s *Int16Set) Fold(base int16, f func(int16, int16) int16) int16 {
	for k := range s.vals {
		base = f(base, k)
	}
	return base
}

// Union returns the union of this set with the provided set. The union of two
// sets A and B is defined by:
//	A union B = {x | (x in A) or (x in B)}
func (s *Int16Set) Union(s2 Int16Set) *Int16Set {
	out := NewInt16Set()

	for k := range s.vals {
		out.vals[k] = true
	}

	for k := range s2.vals {
		out.vals[k] = true
	}

	return out
}

// Intersect returns the intersection of this set with the provided set. The
// intersection of two sets A and B is defined by:
//	A intersect B = {x | (x in A) and (x in B)}
func (s *Int16Set) Intersect(s2 Int16Set) *Int16Set {
	out := NewInt16Set()

	for k := range s.vals {
		if s2.vals[k] {
			out.vals[k] = true
		}
	}

	for k := range s2.vals {
		if s.vals[k] {
			out.vals[k] = true
		}
	}

	return out
}

// Diff returns the set difference of this set with the provided set. The
// set difference of two sets A and B is defined as:
//	A \ B = {x | (x in A) and (x not in B)}
func (s *Int16Set) Diff(s2 Int16Set) *Int16Set {
	out := NewInt16Set()

	for k := range s.vals {
		if !s2.vals[k] {
			out.vals[k] = true
		}
	}

	return out
}

// SymDiff returns the symmetric difference of this set with the provided set.
// The symmetric difference of two sets A and B is defined as:
//	A (+) B = {x | (x in A) xor (x in B)}
func (s *Int16Set) SymDiff(s2 Int16Set) *Int16Set {
	out := NewInt16Set()

	for k := range s.vals {
		if !s2.vals[k] {
			out.vals[k] = true
		}
	}

	for k := range s2.vals {
		if !s.vals[k] {
			out.vals[k] = true
		}
	}

	return out
}

// Int32Set implements the set data structure implemented with a map. The set
// has an optional capacity. By default, this cap is set to zero. Setting a
//positive cap will cause silent failures whenever trying to add elements to a
// full set.
type Int32Set struct {
	vals map[int32]bool
	cap  int
}

// NewInt32Set creates a new set of int32 values.
func NewInt32Set(vals ...int32) *Int32Set {
	s := Int32Set{vals: map[int32]bool{}}
	for _, v := range vals {
		s.vals[v] = true
	}
	return &s
}

func (s *Int32Set) String() string {
	return fmt.Sprintf("%v", s.Enumerate())
}

// Contains checks if the provided value is in the set.
func (s *Int32Set) Contains(val int32) bool {
	return s.vals[val]
}

// IsSubset checks if the set is a subset of b i,e, every element of the set s
// is contained in b.
func (s *Int32Set) IsSubset(b Int32Set) bool {
	if len(s.vals) > len(b.vals) {
		return false
	}

	for k := range s.vals {
		if !b.vals[k] {
			return false
		}
	}

	return true
}

// IsEmpty checks of the set does not contain any elements.
func (s *Int32Set) IsEmpty() bool {
	return len(s.vals) == 0
}

// Len returns the number of elements in the set.
func (s *Int32Set) Len() int {
	return len(s.vals)
}

// Cap returns the capacity of the set.
func (s *Int32Set) Cap() int {
	return s.cap
}

// SetCap sets the capacity of the set. If a negative integer is passed, then
// the capacity is set to 0. A capacity of 0 indicates no capacity.
func (s *Int32Set) SetCap(c int) *Int32Set {
	if c < 0 {
		c = 0
	}

	s.cap = c
	return s
}

// Enumerate returns a slice of the elements in the set that can be used in a
// for ... range loop. Depending on what the data is being used for, consider
// using the Map, Filter, and Fold methods instead as they act on the set
// itself.
func (s *Int32Set) Enumerate() []int32 {
	keys := make([]int32, len(s.vals))
	i := 0
	for k := range s.vals {
		keys[i] = k
		i++
	}
	return keys
}

// Add adds the provided val to the set. If the set has already reached
// capacity, then the addition silently fails.
func (s *Int32Set) Add(val int32) *Int32Set {
	if s.cap > 0 && len(s.vals) == s.cap {
		return s
	}

	s.vals[val] = true
	return s
}

// Remove deletes the provided values from the set. If the value is not in the
// set, then this is a no-op.
func (s *Int32Set) Remove(val int32) *Int32Set {
	delete(s.vals, val)
	return s
}

// Clear removes all elements from the set. This does not clear the capcity.
func (s *Int32Set) Clear() *Int32Set {
	for k := range s.vals {
		delete(s.vals, k)
	}
	return s
}

// Equals checks if the provided set is equal to this set. Sets A and B are
// equal if A is a subset of B and B is a subset of A.
func (s *Int32Set) Equals(s2 Int32Set) bool {
	if len(s.vals) != len(s2.vals) {
		return false
	}

	return s.IsSubset(s2)
}

// Map applies the provided function to every element in the set. Because the
// set must only contain unique elements, the size of the set may change
// after applying the transformation function.
func (s *Int32Set) Map(f func(int32) int32) *Int32Set {
	out := NewInt32Set().SetCap(s.cap)
	for k := range s.vals {
		out.vals[f(k)] = true
	}
	return out
}

// Filter applies the provided function to every element in the set. The
// resulting set contains only the elements that caused the function to
// return true.
func (s *Int32Set) Filter(f func(int32) bool) *Int32Set {
	out := NewInt32Set().SetCap(s.cap)
	for k := range s.vals {
		if f(k) {
			out.vals[k] = true
		}
	}
	return out
}

// Fold reduces the set to a single value by successively applying the provided
// function to elements of the set beginning with the base. The operation
// performed in the provided function must be associative and communitive to
// guarantee a deterministic result.
func (s *Int32Set) Fold(base int32, f func(int32, int32) int32) int32 {
	for k := range s.vals {
		base = f(base, k)
	}
	return base
}

// Union returns the union of this set with the provided set. The union of two
// sets A and B is defined by:
//	A union B = {x | (x in A) or (x in B)}
func (s *Int32Set) Union(s2 Int32Set) *Int32Set {
	out := NewInt32Set()

	for k := range s.vals {
		out.vals[k] = true
	}

	for k := range s2.vals {
		out.vals[k] = true
	}

	return out
}

// Intersect returns the intersection of this set with the provided set. The
// intersection of two sets A and B is defined by:
//	A intersect B = {x | (x in A) and (x in B)}
func (s *Int32Set) Intersect(s2 Int32Set) *Int32Set {
	out := NewInt32Set()

	for k := range s.vals {
		if s2.vals[k] {
			out.vals[k] = true
		}
	}

	for k := range s2.vals {
		if s.vals[k] {
			out.vals[k] = true
		}
	}

	return out
}

// Diff returns the set difference of this set with the provided set. The
// set difference of two sets A and B is defined as:
//	A \ B = {x | (x in A) and (x not in B)}
func (s *Int32Set) Diff(s2 Int32Set) *Int32Set {
	out := NewInt32Set()

	for k := range s.vals {
		if !s2.vals[k] {
			out.vals[k] = true
		}
	}

	return out
}

// SymDiff returns the symmetric difference of this set with the provided set.
// The symmetric difference of two sets A and B is defined as:
//	A (+) B = {x | (x in A) xor (x in B)}
func (s *Int32Set) SymDiff(s2 Int32Set) *Int32Set {
	out := NewInt32Set()

	for k := range s.vals {
		if !s2.vals[k] {
			out.vals[k] = true
		}
	}

	for k := range s2.vals {
		if !s.vals[k] {
			out.vals[k] = true
		}
	}

	return out
}

// Int64Set implements the set data structure implemented with a map. The set
// has an optional capacity. By default, this cap is set to zero. Setting a
//positive cap will cause silent failures whenever trying to add elements to a
// full set.
type Int64Set struct {
	vals map[int64]bool
	cap  int
}

// NewInt64Set creates a new set of int64 values.
func NewInt64Set(vals ...int64) *Int64Set {
	s := Int64Set{vals: map[int64]bool{}}
	for _, v := range vals {
		s.vals[v] = true
	}
	return &s
}

func (s *Int64Set) String() string {
	return fmt.Sprintf("%v", s.Enumerate())
}

// Contains checks if the provided value is in the set.
func (s *Int64Set) Contains(val int64) bool {
	return s.vals[val]
}

// IsSubset checks if the set is a subset of b i,e, every element of the set s
// is contained in b.
func (s *Int64Set) IsSubset(b Int64Set) bool {
	if len(s.vals) > len(b.vals) {
		return false
	}

	for k := range s.vals {
		if !b.vals[k] {
			return false
		}
	}

	return true
}

// IsEmpty checks of the set does not contain any elements.
func (s *Int64Set) IsEmpty() bool {
	return len(s.vals) == 0
}

// Len returns the number of elements in the set.
func (s *Int64Set) Len() int {
	return len(s.vals)
}

// Cap returns the capacity of the set.
func (s *Int64Set) Cap() int {
	return s.cap
}

// SetCap sets the capacity of the set. If a negative integer is passed, then
// the capacity is set to 0. A capacity of 0 indicates no capacity.
func (s *Int64Set) SetCap(c int) *Int64Set {
	if c < 0 {
		c = 0
	}

	s.cap = c
	return s
}

// Enumerate returns a slice of the elements in the set that can be used in a
// for ... range loop. Depending on what the data is being used for, consider
// using the Map, Filter, and Fold methods instead as they act on the set
// itself.
func (s *Int64Set) Enumerate() []int64 {
	keys := make([]int64, len(s.vals))
	i := 0
	for k := range s.vals {
		keys[i] = k
		i++
	}
	return keys
}

// Add adds the provided val to the set. If the set has already reached
// capacity, then the addition silently fails.
func (s *Int64Set) Add(val int64) *Int64Set {
	if s.cap > 0 && len(s.vals) == s.cap {
		return s
	}

	s.vals[val] = true
	return s
}

// Remove deletes the provided values from the set. If the value is not in the
// set, then this is a no-op.
func (s *Int64Set) Remove(val int64) *Int64Set {
	delete(s.vals, val)
	return s
}

// Clear removes all elements from the set. This does not clear the capcity.
func (s *Int64Set) Clear() *Int64Set {
	for k := range s.vals {
		delete(s.vals, k)
	}
	return s
}

// Equals checks if the provided set is equal to this set. Sets A and B are
// equal if A is a subset of B and B is a subset of A.
func (s *Int64Set) Equals(s2 Int64Set) bool {
	if len(s.vals) != len(s2.vals) {
		return false
	}

	return s.IsSubset(s2)
}

// Map applies the provided function to every element in the set. Because the
// set must only contain unique elements, the size of the set may change
// after applying the transformation function.
func (s *Int64Set) Map(f func(int64) int64) *Int64Set {
	out := NewInt64Set().SetCap(s.cap)
	for k := range s.vals {
		out.vals[f(k)] = true
	}
	return out
}

// Filter applies the provided function to every element in the set. The
// resulting set contains only the elements that caused the function to
// return true.
func (s *Int64Set) Filter(f func(int64) bool) *Int64Set {
	out := NewInt64Set().SetCap(s.cap)
	for k := range s.vals {
		if f(k) {
			out.vals[k] = true
		}
	}
	return out
}

// Fold reduces the set to a single value by successively applying the provided
// function to elements of the set beginning with the base. The operation
// performed in the provided function must be associative and communitive to
// guarantee a deterministic result.
func (s *Int64Set) Fold(base int64, f func(int64, int64) int64) int64 {
	for k := range s.vals {
		base = f(base, k)
	}
	return base
}

// Union returns the union of this set with the provided set. The union of two
// sets A and B is defined by:
//	A union B = {x | (x in A) or (x in B)}
func (s *Int64Set) Union(s2 Int64Set) *Int64Set {
	out := NewInt64Set()

	for k := range s.vals {
		out.vals[k] = true
	}

	for k := range s2.vals {
		out.vals[k] = true
	}

	return out
}

// Intersect returns the intersection of this set with the provided set. The
// intersection of two sets A and B is defined by:
//	A intersect B = {x | (x in A) and (x in B)}
func (s *Int64Set) Intersect(s2 Int64Set) *Int64Set {
	out := NewInt64Set()

	for k := range s.vals {
		if s2.vals[k] {
			out.vals[k] = true
		}
	}

	for k := range s2.vals {
		if s.vals[k] {
			out.vals[k] = true
		}
	}

	return out
}

// Diff returns the set difference of this set with the provided set. The
// set difference of two sets A and B is defined as:
//	A \ B = {x | (x in A) and (x not in B)}
func (s *Int64Set) Diff(s2 Int64Set) *Int64Set {
	out := NewInt64Set()

	for k := range s.vals {
		if !s2.vals[k] {
			out.vals[k] = true
		}
	}

	return out
}

// SymDiff returns the symmetric difference of this set with the provided set.
// The symmetric difference of two sets A and B is defined as:
//	A (+) B = {x | (x in A) xor (x in B)}
func (s *Int64Set) SymDiff(s2 Int64Set) *Int64Set {
	out := NewInt64Set()

	for k := range s.vals {
		if !s2.vals[k] {
			out.vals[k] = true
		}
	}

	for k := range s2.vals {
		if !s.vals[k] {
			out.vals[k] = true
		}
	}

	return out
}

// Int8Set implements the set data structure implemented with a map. The set
// has an optional capacity. By default, this cap is set to zero. Setting a
//positive cap will cause silent failures whenever trying to add elements to a
// full set.
type Int8Set struct {
	vals map[int8]bool
	cap  int
}

// NewInt8Set creates a new set of int8 values.
func NewInt8Set(vals ...int8) *Int8Set {
	s := Int8Set{vals: map[int8]bool{}}
	for _, v := range vals {
		s.vals[v] = true
	}
	return &s
}

func (s *Int8Set) String() string {
	return fmt.Sprintf("%v", s.Enumerate())
}

// Contains checks if the provided value is in the set.
func (s *Int8Set) Contains(val int8) bool {
	return s.vals[val]
}

// IsSubset checks if the set is a subset of b i,e, every element of the set s
// is contained in b.
func (s *Int8Set) IsSubset(b Int8Set) bool {
	if len(s.vals) > len(b.vals) {
		return false
	}

	for k := range s.vals {
		if !b.vals[k] {
			return false
		}
	}

	return true
}

// IsEmpty checks of the set does not contain any elements.
func (s *Int8Set) IsEmpty() bool {
	return len(s.vals) == 0
}

// Len returns the number of elements in the set.
func (s *Int8Set) Len() int {
	return len(s.vals)
}

// Cap returns the capacity of the set.
func (s *Int8Set) Cap() int {
	return s.cap
}

// SetCap sets the capacity of the set. If a negative integer is passed, then
// the capacity is set to 0. A capacity of 0 indicates no capacity.
func (s *Int8Set) SetCap(c int) *Int8Set {
	if c < 0 {
		c = 0
	}

	s.cap = c
	return s
}

// Enumerate returns a slice of the elements in the set that can be used in a
// for ... range loop. Depending on what the data is being used for, consider
// using the Map, Filter, and Fold methods instead as they act on the set
// itself.
func (s *Int8Set) Enumerate() []int8 {
	keys := make([]int8, len(s.vals))
	i := 0
	for k := range s.vals {
		keys[i] = k
		i++
	}
	return keys
}

// Add adds the provided val to the set. If the set has already reached
// capacity, then the addition silently fails.
func (s *Int8Set) Add(val int8) *Int8Set {
	if s.cap > 0 && len(s.vals) == s.cap {
		return s
	}

	s.vals[val] = true
	return s
}

// Remove deletes the provided values from the set. If the value is not in the
// set, then this is a no-op.
func (s *Int8Set) Remove(val int8) *Int8Set {
	delete(s.vals, val)
	return s
}

// Clear removes all elements from the set. This does not clear the capcity.
func (s *Int8Set) Clear() *Int8Set {
	for k := range s.vals {
		delete(s.vals, k)
	}
	return s
}

// Equals checks if the provided set is equal to this set. Sets A and B are
// equal if A is a subset of B and B is a subset of A.
func (s *Int8Set) Equals(s2 Int8Set) bool {
	if len(s.vals) != len(s2.vals) {
		return false
	}

	return s.IsSubset(s2)
}

// Map applies the provided function to every element in the set. Because the
// set must only contain unique elements, the size of the set may change
// after applying the transformation function.
func (s *Int8Set) Map(f func(int8) int8) *Int8Set {
	out := NewInt8Set().SetCap(s.cap)
	for k := range s.vals {
		out.vals[f(k)] = true
	}
	return out
}

// Filter applies the provided function to every element in the set. The
// resulting set contains only the elements that caused the function to
// return true.
func (s *Int8Set) Filter(f func(int8) bool) *Int8Set {
	out := NewInt8Set().SetCap(s.cap)
	for k := range s.vals {
		if f(k) {
			out.vals[k] = true
		}
	}
	return out
}

// Fold reduces the set to a single value by successively applying the provided
// function to elements of the set beginning with the base. The operation
// performed in the provided function must be associative and communitive to
// guarantee a deterministic result.
func (s *Int8Set) Fold(base int8, f func(int8, int8) int8) int8 {
	for k := range s.vals {
		base = f(base, k)
	}
	return base
}

// Union returns the union of this set with the provided set. The union of two
// sets A and B is defined by:
//	A union B = {x | (x in A) or (x in B)}
func (s *Int8Set) Union(s2 Int8Set) *Int8Set {
	out := NewInt8Set()

	for k := range s.vals {
		out.vals[k] = true
	}

	for k := range s2.vals {
		out.vals[k] = true
	}

	return out
}

// Intersect returns the intersection of this set with the provided set. The
// intersection of two sets A and B is defined by:
//	A intersect B = {x | (x in A) and (x in B)}
func (s *Int8Set) Intersect(s2 Int8Set) *Int8Set {
	out := NewInt8Set()

	for k := range s.vals {
		if s2.vals[k] {
			out.vals[k] = true
		}
	}

	for k := range s2.vals {
		if s.vals[k] {
			out.vals[k] = true
		}
	}

	return out
}

// Diff returns the set difference of this set with the provided set. The
// set difference of two sets A and B is defined as:
//	A \ B = {x | (x in A) and (x not in B)}
func (s *Int8Set) Diff(s2 Int8Set) *Int8Set {
	out := NewInt8Set()

	for k := range s.vals {
		if !s2.vals[k] {
			out.vals[k] = true
		}
	}

	return out
}

// SymDiff returns the symmetric difference of this set with the provided set.
// The symmetric difference of two sets A and B is defined as:
//	A (+) B = {x | (x in A) xor (x in B)}
func (s *Int8Set) SymDiff(s2 Int8Set) *Int8Set {
	out := NewInt8Set()

	for k := range s.vals {
		if !s2.vals[k] {
			out.vals[k] = true
		}
	}

	for k := range s2.vals {
		if !s.vals[k] {
			out.vals[k] = true
		}
	}

	return out
}

// UintSet implements the set data structure implemented with a map. The set
// has an optional capacity. By default, this cap is set to zero. Setting a
//positive cap will cause silent failures whenever trying to add elements to a
// full set.
type UintSet struct {
	vals map[uint]bool
	cap  int
}

// NewUintSet creates a new set of uint values.
func NewUintSet(vals ...uint) *UintSet {
	s := UintSet{vals: map[uint]bool{}}
	for _, v := range vals {
		s.vals[v] = true
	}
	return &s
}

func (s *UintSet) String() string {
	return fmt.Sprintf("%v", s.Enumerate())
}

// Contains checks if the provided value is in the set.
func (s *UintSet) Contains(val uint) bool {
	return s.vals[val]
}

// IsSubset checks if the set is a subset of b i,e, every element of the set s
// is contained in b.
func (s *UintSet) IsSubset(b UintSet) bool {
	if len(s.vals) > len(b.vals) {
		return false
	}

	for k := range s.vals {
		if !b.vals[k] {
			return false
		}
	}

	return true
}

// IsEmpty checks of the set does not contain any elements.
func (s *UintSet) IsEmpty() bool {
	return len(s.vals) == 0
}

// Len returns the number of elements in the set.
func (s *UintSet) Len() int {
	return len(s.vals)
}

// Cap returns the capacity of the set.
func (s *UintSet) Cap() int {
	return s.cap
}

// SetCap sets the capacity of the set. If a negative integer is passed, then
// the capacity is set to 0. A capacity of 0 indicates no capacity.
func (s *UintSet) SetCap(c int) *UintSet {
	if c < 0 {
		c = 0
	}

	s.cap = c
	return s
}

// Enumerate returns a slice of the elements in the set that can be used in a
// for ... range loop. Depending on what the data is being used for, consider
// using the Map, Filter, and Fold methods instead as they act on the set
// itself.
func (s *UintSet) Enumerate() []uint {
	keys := make([]uint, len(s.vals))
	i := 0
	for k := range s.vals {
		keys[i] = k
		i++
	}
	return keys
}

// Add adds the provided val to the set. If the set has already reached
// capacity, then the addition silently fails.
func (s *UintSet) Add(val uint) *UintSet {
	if s.cap > 0 && len(s.vals) == s.cap {
		return s
	}

	s.vals[val] = true
	return s
}

// Remove deletes the provided values from the set. If the value is not in the
// set, then this is a no-op.
func (s *UintSet) Remove(val uint) *UintSet {
	delete(s.vals, val)
	return s
}

// Clear removes all elements from the set. This does not clear the capcity.
func (s *UintSet) Clear() *UintSet {
	for k := range s.vals {
		delete(s.vals, k)
	}
	return s
}

// Equals checks if the provided set is equal to this set. Sets A and B are
// equal if A is a subset of B and B is a subset of A.
func (s *UintSet) Equals(s2 UintSet) bool {
	if len(s.vals) != len(s2.vals) {
		return false
	}

	return s.IsSubset(s2)
}

// Map applies the provided function to every element in the set. Because the
// set must only contain unique elements, the size of the set may change
// after applying the transformation function.
func (s *UintSet) Map(f func(uint) uint) *UintSet {
	out := NewUintSet().SetCap(s.cap)
	for k := range s.vals {
		out.vals[f(k)] = true
	}
	return out
}

// Filter applies the provided function to every element in the set. The
// resulting set contains only the elements that caused the function to
// return true.
func (s *UintSet) Filter(f func(uint) bool) *UintSet {
	out := NewUintSet().SetCap(s.cap)
	for k := range s.vals {
		if f(k) {
			out.vals[k] = true
		}
	}
	return out
}

// Fold reduces the set to a single value by successively applying the provided
// function to elements of the set beginning with the base. The operation
// performed in the provided function must be associative and communitive to
// guarantee a deterministic result.
func (s *UintSet) Fold(base uint, f func(uint, uint) uint) uint {
	for k := range s.vals {
		base = f(base, k)
	}
	return base
}

// Union returns the union of this set with the provided set. The union of two
// sets A and B is defined by:
//	A union B = {x | (x in A) or (x in B)}
func (s *UintSet) Union(s2 UintSet) *UintSet {
	out := NewUintSet()

	for k := range s.vals {
		out.vals[k] = true
	}

	for k := range s2.vals {
		out.vals[k] = true
	}

	return out
}

// Intersect returns the intersection of this set with the provided set. The
// intersection of two sets A and B is defined by:
//	A intersect B = {x | (x in A) and (x in B)}
func (s *UintSet) Intersect(s2 UintSet) *UintSet {
	out := NewUintSet()

	for k := range s.vals {
		if s2.vals[k] {
			out.vals[k] = true
		}
	}

	for k := range s2.vals {
		if s.vals[k] {
			out.vals[k] = true
		}
	}

	return out
}

// Diff returns the set difference of this set with the provided set. The
// set difference of two sets A and B is defined as:
//	A \ B = {x | (x in A) and (x not in B)}
func (s *UintSet) Diff(s2 UintSet) *UintSet {
	out := NewUintSet()

	for k := range s.vals {
		if !s2.vals[k] {
			out.vals[k] = true
		}
	}

	return out
}

// SymDiff returns the symmetric difference of this set with the provided set.
// The symmetric difference of two sets A and B is defined as:
//	A (+) B = {x | (x in A) xor (x in B)}
func (s *UintSet) SymDiff(s2 UintSet) *UintSet {
	out := NewUintSet()

	for k := range s.vals {
		if !s2.vals[k] {
			out.vals[k] = true
		}
	}

	for k := range s2.vals {
		if !s.vals[k] {
			out.vals[k] = true
		}
	}

	return out
}

// Uint16Set implements the set data structure implemented with a map. The set
// has an optional capacity. By default, this cap is set to zero. Setting a
//positive cap will cause silent failures whenever trying to add elements to a
// full set.
type Uint16Set struct {
	vals map[uint16]bool
	cap  int
}

// NewUint16Set creates a new set of uint16 values.
func NewUint16Set(vals ...uint16) *Uint16Set {
	s := Uint16Set{vals: map[uint16]bool{}}
	for _, v := range vals {
		s.vals[v] = true
	}
	return &s
}

func (s *Uint16Set) String() string {
	return fmt.Sprintf("%v", s.Enumerate())
}

// Contains checks if the provided value is in the set.
func (s *Uint16Set) Contains(val uint16) bool {
	return s.vals[val]
}

// IsSubset checks if the set is a subset of b i,e, every element of the set s
// is contained in b.
func (s *Uint16Set) IsSubset(b Uint16Set) bool {
	if len(s.vals) > len(b.vals) {
		return false
	}

	for k := range s.vals {
		if !b.vals[k] {
			return false
		}
	}

	return true
}

// IsEmpty checks of the set does not contain any elements.
func (s *Uint16Set) IsEmpty() bool {
	return len(s.vals) == 0
}

// Len returns the number of elements in the set.
func (s *Uint16Set) Len() int {
	return len(s.vals)
}

// Cap returns the capacity of the set.
func (s *Uint16Set) Cap() int {
	return s.cap
}

// SetCap sets the capacity of the set. If a negative integer is passed, then
// the capacity is set to 0. A capacity of 0 indicates no capacity.
func (s *Uint16Set) SetCap(c int) *Uint16Set {
	if c < 0 {
		c = 0
	}

	s.cap = c
	return s
}

// Enumerate returns a slice of the elements in the set that can be used in a
// for ... range loop. Depending on what the data is being used for, consider
// using the Map, Filter, and Fold methods instead as they act on the set
// itself.
func (s *Uint16Set) Enumerate() []uint16 {
	keys := make([]uint16, len(s.vals))
	i := 0
	for k := range s.vals {
		keys[i] = k
		i++
	}
	return keys
}

// Add adds the provided val to the set. If the set has already reached
// capacity, then the addition silently fails.
func (s *Uint16Set) Add(val uint16) *Uint16Set {
	if s.cap > 0 && len(s.vals) == s.cap {
		return s
	}

	s.vals[val] = true
	return s
}

// Remove deletes the provided values from the set. If the value is not in the
// set, then this is a no-op.
func (s *Uint16Set) Remove(val uint16) *Uint16Set {
	delete(s.vals, val)
	return s
}

// Clear removes all elements from the set. This does not clear the capcity.
func (s *Uint16Set) Clear() *Uint16Set {
	for k := range s.vals {
		delete(s.vals, k)
	}
	return s
}

// Equals checks if the provided set is equal to this set. Sets A and B are
// equal if A is a subset of B and B is a subset of A.
func (s *Uint16Set) Equals(s2 Uint16Set) bool {
	if len(s.vals) != len(s2.vals) {
		return false
	}

	return s.IsSubset(s2)
}

// Map applies the provided function to every element in the set. Because the
// set must only contain unique elements, the size of the set may change
// after applying the transformation function.
func (s *Uint16Set) Map(f func(uint16) uint16) *Uint16Set {
	out := NewUint16Set().SetCap(s.cap)
	for k := range s.vals {
		out.vals[f(k)] = true
	}
	return out
}

// Filter applies the provided function to every element in the set. The
// resulting set contains only the elements that caused the function to
// return true.
func (s *Uint16Set) Filter(f func(uint16) bool) *Uint16Set {
	out := NewUint16Set().SetCap(s.cap)
	for k := range s.vals {
		if f(k) {
			out.vals[k] = true
		}
	}
	return out
}

// Fold reduces the set to a single value by successively applying the provided
// function to elements of the set beginning with the base. The operation
// performed in the provided function must be associative and communitive to
// guarantee a deterministic result.
func (s *Uint16Set) Fold(base uint16, f func(uint16, uint16) uint16) uint16 {
	for k := range s.vals {
		base = f(base, k)
	}
	return base
}

// Union returns the union of this set with the provided set. The union of two
// sets A and B is defined by:
//	A union B = {x | (x in A) or (x in B)}
func (s *Uint16Set) Union(s2 Uint16Set) *Uint16Set {
	out := NewUint16Set()

	for k := range s.vals {
		out.vals[k] = true
	}

	for k := range s2.vals {
		out.vals[k] = true
	}

	return out
}

// Intersect returns the intersection of this set with the provided set. The
// intersection of two sets A and B is defined by:
//	A intersect B = {x | (x in A) and (x in B)}
func (s *Uint16Set) Intersect(s2 Uint16Set) *Uint16Set {
	out := NewUint16Set()

	for k := range s.vals {
		if s2.vals[k] {
			out.vals[k] = true
		}
	}

	for k := range s2.vals {
		if s.vals[k] {
			out.vals[k] = true
		}
	}

	return out
}

// Diff returns the set difference of this set with the provided set. The
// set difference of two sets A and B is defined as:
//	A \ B = {x | (x in A) and (x not in B)}
func (s *Uint16Set) Diff(s2 Uint16Set) *Uint16Set {
	out := NewUint16Set()

	for k := range s.vals {
		if !s2.vals[k] {
			out.vals[k] = true
		}
	}

	return out
}

// SymDiff returns the symmetric difference of this set with the provided set.
// The symmetric difference of two sets A and B is defined as:
//	A (+) B = {x | (x in A) xor (x in B)}
func (s *Uint16Set) SymDiff(s2 Uint16Set) *Uint16Set {
	out := NewUint16Set()

	for k := range s.vals {
		if !s2.vals[k] {
			out.vals[k] = true
		}
	}

	for k := range s2.vals {
		if !s.vals[k] {
			out.vals[k] = true
		}
	}

	return out
}

// Uint32Set implements the set data structure implemented with a map. The set
// has an optional capacity. By default, this cap is set to zero. Setting a
//positive cap will cause silent failures whenever trying to add elements to a
// full set.
type Uint32Set struct {
	vals map[uint32]bool
	cap  int
}

// NewUint32Set creates a new set of uint32 values.
func NewUint32Set(vals ...uint32) *Uint32Set {
	s := Uint32Set{vals: map[uint32]bool{}}
	for _, v := range vals {
		s.vals[v] = true
	}
	return &s
}

func (s *Uint32Set) String() string {
	return fmt.Sprintf("%v", s.Enumerate())
}

// Contains checks if the provided value is in the set.
func (s *Uint32Set) Contains(val uint32) bool {
	return s.vals[val]
}

// IsSubset checks if the set is a subset of b i,e, every element of the set s
// is contained in b.
func (s *Uint32Set) IsSubset(b Uint32Set) bool {
	if len(s.vals) > len(b.vals) {
		return false
	}

	for k := range s.vals {
		if !b.vals[k] {
			return false
		}
	}

	return true
}

// IsEmpty checks of the set does not contain any elements.
func (s *Uint32Set) IsEmpty() bool {
	return len(s.vals) == 0
}

// Len returns the number of elements in the set.
func (s *Uint32Set) Len() int {
	return len(s.vals)
}

// Cap returns the capacity of the set.
func (s *Uint32Set) Cap() int {
	return s.cap
}

// SetCap sets the capacity of the set. If a negative integer is passed, then
// the capacity is set to 0. A capacity of 0 indicates no capacity.
func (s *Uint32Set) SetCap(c int) *Uint32Set {
	if c < 0 {
		c = 0
	}

	s.cap = c
	return s
}

// Enumerate returns a slice of the elements in the set that can be used in a
// for ... range loop. Depending on what the data is being used for, consider
// using the Map, Filter, and Fold methods instead as they act on the set
// itself.
func (s *Uint32Set) Enumerate() []uint32 {
	keys := make([]uint32, len(s.vals))
	i := 0
	for k := range s.vals {
		keys[i] = k
		i++
	}
	return keys
}

// Add adds the provided val to the set. If the set has already reached
// capacity, then the addition silently fails.
func (s *Uint32Set) Add(val uint32) *Uint32Set {
	if s.cap > 0 && len(s.vals) == s.cap {
		return s
	}

	s.vals[val] = true
	return s
}

// Remove deletes the provided values from the set. If the value is not in the
// set, then this is a no-op.
func (s *Uint32Set) Remove(val uint32) *Uint32Set {
	delete(s.vals, val)
	return s
}

// Clear removes all elements from the set. This does not clear the capcity.
func (s *Uint32Set) Clear() *Uint32Set {
	for k := range s.vals {
		delete(s.vals, k)
	}
	return s
}

// Equals checks if the provided set is equal to this set. Sets A and B are
// equal if A is a subset of B and B is a subset of A.
func (s *Uint32Set) Equals(s2 Uint32Set) bool {
	if len(s.vals) != len(s2.vals) {
		return false
	}

	return s.IsSubset(s2)
}

// Map applies the provided function to every element in the set. Because the
// set must only contain unique elements, the size of the set may change
// after applying the transformation function.
func (s *Uint32Set) Map(f func(uint32) uint32) *Uint32Set {
	out := NewUint32Set().SetCap(s.cap)
	for k := range s.vals {
		out.vals[f(k)] = true
	}
	return out
}

// Filter applies the provided function to every element in the set. The
// resulting set contains only the elements that caused the function to
// return true.
func (s *Uint32Set) Filter(f func(uint32) bool) *Uint32Set {
	out := NewUint32Set().SetCap(s.cap)
	for k := range s.vals {
		if f(k) {
			out.vals[k] = true
		}
	}
	return out
}

// Fold reduces the set to a single value by successively applying the provided
// function to elements of the set beginning with the base. The operation
// performed in the provided function must be associative and communitive to
// guarantee a deterministic result.
func (s *Uint32Set) Fold(base uint32, f func(uint32, uint32) uint32) uint32 {
	for k := range s.vals {
		base = f(base, k)
	}
	return base
}

// Union returns the union of this set with the provided set. The union of two
// sets A and B is defined by:
//	A union B = {x | (x in A) or (x in B)}
func (s *Uint32Set) Union(s2 Uint32Set) *Uint32Set {
	out := NewUint32Set()

	for k := range s.vals {
		out.vals[k] = true
	}

	for k := range s2.vals {
		out.vals[k] = true
	}

	return out
}

// Intersect returns the intersection of this set with the provided set. The
// intersection of two sets A and B is defined by:
//	A intersect B = {x | (x in A) and (x in B)}
func (s *Uint32Set) Intersect(s2 Uint32Set) *Uint32Set {
	out := NewUint32Set()

	for k := range s.vals {
		if s2.vals[k] {
			out.vals[k] = true
		}
	}

	for k := range s2.vals {
		if s.vals[k] {
			out.vals[k] = true
		}
	}

	return out
}

// Diff returns the set difference of this set with the provided set. The
// set difference of two sets A and B is defined as:
//	A \ B = {x | (x in A) and (x not in B)}
func (s *Uint32Set) Diff(s2 Uint32Set) *Uint32Set {
	out := NewUint32Set()

	for k := range s.vals {
		if !s2.vals[k] {
			out.vals[k] = true
		}
	}

	return out
}

// SymDiff returns the symmetric difference of this set with the provided set.
// The symmetric difference of two sets A and B is defined as:
//	A (+) B = {x | (x in A) xor (x in B)}
func (s *Uint32Set) SymDiff(s2 Uint32Set) *Uint32Set {
	out := NewUint32Set()

	for k := range s.vals {
		if !s2.vals[k] {
			out.vals[k] = true
		}
	}

	for k := range s2.vals {
		if !s.vals[k] {
			out.vals[k] = true
		}
	}

	return out
}

// Uint64Set implements the set data structure implemented with a map. The set
// has an optional capacity. By default, this cap is set to zero. Setting a
//positive cap will cause silent failures whenever trying to add elements to a
// full set.
type Uint64Set struct {
	vals map[uint64]bool
	cap  int
}

// NewUint64Set creates a new set of uint64 values.
func NewUint64Set(vals ...uint64) *Uint64Set {
	s := Uint64Set{vals: map[uint64]bool{}}
	for _, v := range vals {
		s.vals[v] = true
	}
	return &s
}

func (s *Uint64Set) String() string {
	return fmt.Sprintf("%v", s.Enumerate())
}

// Contains checks if the provided value is in the set.
func (s *Uint64Set) Contains(val uint64) bool {
	return s.vals[val]
}

// IsSubset checks if the set is a subset of b i,e, every element of the set s
// is contained in b.
func (s *Uint64Set) IsSubset(b Uint64Set) bool {
	if len(s.vals) > len(b.vals) {
		return false
	}

	for k := range s.vals {
		if !b.vals[k] {
			return false
		}
	}

	return true
}

// IsEmpty checks of the set does not contain any elements.
func (s *Uint64Set) IsEmpty() bool {
	return len(s.vals) == 0
}

// Len returns the number of elements in the set.
func (s *Uint64Set) Len() int {
	return len(s.vals)
}

// Cap returns the capacity of the set.
func (s *Uint64Set) Cap() int {
	return s.cap
}

// SetCap sets the capacity of the set. If a negative integer is passed, then
// the capacity is set to 0. A capacity of 0 indicates no capacity.
func (s *Uint64Set) SetCap(c int) *Uint64Set {
	if c < 0 {
		c = 0
	}

	s.cap = c
	return s
}

// Enumerate returns a slice of the elements in the set that can be used in a
// for ... range loop. Depending on what the data is being used for, consider
// using the Map, Filter, and Fold methods instead as they act on the set
// itself.
func (s *Uint64Set) Enumerate() []uint64 {
	keys := make([]uint64, len(s.vals))
	i := 0
	for k := range s.vals {
		keys[i] = k
		i++
	}
	return keys
}

// Add adds the provided val to the set. If the set has already reached
// capacity, then the addition silently fails.
func (s *Uint64Set) Add(val uint64) *Uint64Set {
	if s.cap > 0 && len(s.vals) == s.cap {
		return s
	}

	s.vals[val] = true
	return s
}

// Remove deletes the provided values from the set. If the value is not in the
// set, then this is a no-op.
func (s *Uint64Set) Remove(val uint64) *Uint64Set {
	delete(s.vals, val)
	return s
}

// Clear removes all elements from the set. This does not clear the capcity.
func (s *Uint64Set) Clear() *Uint64Set {
	for k := range s.vals {
		delete(s.vals, k)
	}
	return s
}

// Equals checks if the provided set is equal to this set. Sets A and B are
// equal if A is a subset of B and B is a subset of A.
func (s *Uint64Set) Equals(s2 Uint64Set) bool {
	if len(s.vals) != len(s2.vals) {
		return false
	}

	return s.IsSubset(s2)
}

// Map applies the provided function to every element in the set. Because the
// set must only contain unique elements, the size of the set may change
// after applying the transformation function.
func (s *Uint64Set) Map(f func(uint64) uint64) *Uint64Set {
	out := NewUint64Set().SetCap(s.cap)
	for k := range s.vals {
		out.vals[f(k)] = true
	}
	return out
}

// Filter applies the provided function to every element in the set. The
// resulting set contains only the elements that caused the function to
// return true.
func (s *Uint64Set) Filter(f func(uint64) bool) *Uint64Set {
	out := NewUint64Set().SetCap(s.cap)
	for k := range s.vals {
		if f(k) {
			out.vals[k] = true
		}
	}
	return out
}

// Fold reduces the set to a single value by successively applying the provided
// function to elements of the set beginning with the base. The operation
// performed in the provided function must be associative and communitive to
// guarantee a deterministic result.
func (s *Uint64Set) Fold(base uint64, f func(uint64, uint64) uint64) uint64 {
	for k := range s.vals {
		base = f(base, k)
	}
	return base
}

// Union returns the union of this set with the provided set. The union of two
// sets A and B is defined by:
//	A union B = {x | (x in A) or (x in B)}
func (s *Uint64Set) Union(s2 Uint64Set) *Uint64Set {
	out := NewUint64Set()

	for k := range s.vals {
		out.vals[k] = true
	}

	for k := range s2.vals {
		out.vals[k] = true
	}

	return out
}

// Intersect returns the intersection of this set with the provided set. The
// intersection of two sets A and B is defined by:
//	A intersect B = {x | (x in A) and (x in B)}
func (s *Uint64Set) Intersect(s2 Uint64Set) *Uint64Set {
	out := NewUint64Set()

	for k := range s.vals {
		if s2.vals[k] {
			out.vals[k] = true
		}
	}

	for k := range s2.vals {
		if s.vals[k] {
			out.vals[k] = true
		}
	}

	return out
}

// Diff returns the set difference of this set with the provided set. The
// set difference of two sets A and B is defined as:
//	A \ B = {x | (x in A) and (x not in B)}
func (s *Uint64Set) Diff(s2 Uint64Set) *Uint64Set {
	out := NewUint64Set()

	for k := range s.vals {
		if !s2.vals[k] {
			out.vals[k] = true
		}
	}

	return out
}

// SymDiff returns the symmetric difference of this set with the provided set.
// The symmetric difference of two sets A and B is defined as:
//	A (+) B = {x | (x in A) xor (x in B)}
func (s *Uint64Set) SymDiff(s2 Uint64Set) *Uint64Set {
	out := NewUint64Set()

	for k := range s.vals {
		if !s2.vals[k] {
			out.vals[k] = true
		}
	}

	for k := range s2.vals {
		if !s.vals[k] {
			out.vals[k] = true
		}
	}

	return out
}

// Uint8Set implements the set data structure implemented with a map. The set
// has an optional capacity. By default, this cap is set to zero. Setting a
//positive cap will cause silent failures whenever trying to add elements to a
// full set.
type Uint8Set struct {
	vals map[uint8]bool
	cap  int
}

// NewUint8Set creates a new set of uint8 values.
func NewUint8Set(vals ...uint8) *Uint8Set {
	s := Uint8Set{vals: map[uint8]bool{}}
	for _, v := range vals {
		s.vals[v] = true
	}
	return &s
}

func (s *Uint8Set) String() string {
	return fmt.Sprintf("%v", s.Enumerate())
}

// Contains checks if the provided value is in the set.
func (s *Uint8Set) Contains(val uint8) bool {
	return s.vals[val]
}

// IsSubset checks if the set is a subset of b i,e, every element of the set s
// is contained in b.
func (s *Uint8Set) IsSubset(b Uint8Set) bool {
	if len(s.vals) > len(b.vals) {
		return false
	}

	for k := range s.vals {
		if !b.vals[k] {
			return false
		}
	}

	return true
}

// IsEmpty checks of the set does not contain any elements.
func (s *Uint8Set) IsEmpty() bool {
	return len(s.vals) == 0
}

// Len returns the number of elements in the set.
func (s *Uint8Set) Len() int {
	return len(s.vals)
}

// Cap returns the capacity of the set.
func (s *Uint8Set) Cap() int {
	return s.cap
}

// SetCap sets the capacity of the set. If a negative integer is passed, then
// the capacity is set to 0. A capacity of 0 indicates no capacity.
func (s *Uint8Set) SetCap(c int) *Uint8Set {
	if c < 0 {
		c = 0
	}

	s.cap = c
	return s
}

// Enumerate returns a slice of the elements in the set that can be used in a
// for ... range loop. Depending on what the data is being used for, consider
// using the Map, Filter, and Fold methods instead as they act on the set
// itself.
func (s *Uint8Set) Enumerate() []uint8 {
	keys := make([]uint8, len(s.vals))
	i := 0
	for k := range s.vals {
		keys[i] = k
		i++
	}
	return keys
}

// Add adds the provided val to the set. If the set has already reached
// capacity, then the addition silently fails.
func (s *Uint8Set) Add(val uint8) *Uint8Set {
	if s.cap > 0 && len(s.vals) == s.cap {
		return s
	}

	s.vals[val] = true
	return s
}

// Remove deletes the provided values from the set. If the value is not in the
// set, then this is a no-op.
func (s *Uint8Set) Remove(val uint8) *Uint8Set {
	delete(s.vals, val)
	return s
}

// Clear removes all elements from the set. This does not clear the capcity.
func (s *Uint8Set) Clear() *Uint8Set {
	for k := range s.vals {
		delete(s.vals, k)
	}
	return s
}

// Equals checks if the provided set is equal to this set. Sets A and B are
// equal if A is a subset of B and B is a subset of A.
func (s *Uint8Set) Equals(s2 Uint8Set) bool {
	if len(s.vals) != len(s2.vals) {
		return false
	}

	return s.IsSubset(s2)
}

// Map applies the provided function to every element in the set. Because the
// set must only contain unique elements, the size of the set may change
// after applying the transformation function.
func (s *Uint8Set) Map(f func(uint8) uint8) *Uint8Set {
	out := NewUint8Set().SetCap(s.cap)
	for k := range s.vals {
		out.vals[f(k)] = true
	}
	return out
}

// Filter applies the provided function to every element in the set. The
// resulting set contains only the elements that caused the function to
// return true.
func (s *Uint8Set) Filter(f func(uint8) bool) *Uint8Set {
	out := NewUint8Set().SetCap(s.cap)
	for k := range s.vals {
		if f(k) {
			out.vals[k] = true
		}
	}
	return out
}

// Fold reduces the set to a single value by successively applying the provided
// function to elements of the set beginning with the base. The operation
// performed in the provided function must be associative and communitive to
// guarantee a deterministic result.
func (s *Uint8Set) Fold(base uint8, f func(uint8, uint8) uint8) uint8 {
	for k := range s.vals {
		base = f(base, k)
	}
	return base
}

// Union returns the union of this set with the provided set. The union of two
// sets A and B is defined by:
//	A union B = {x | (x in A) or (x in B)}
func (s *Uint8Set) Union(s2 Uint8Set) *Uint8Set {
	out := NewUint8Set()

	for k := range s.vals {
		out.vals[k] = true
	}

	for k := range s2.vals {
		out.vals[k] = true
	}

	return out
}

// Intersect returns the intersection of this set with the provided set. The
// intersection of two sets A and B is defined by:
//	A intersect B = {x | (x in A) and (x in B)}
func (s *Uint8Set) Intersect(s2 Uint8Set) *Uint8Set {
	out := NewUint8Set()

	for k := range s.vals {
		if s2.vals[k] {
			out.vals[k] = true
		}
	}

	for k := range s2.vals {
		if s.vals[k] {
			out.vals[k] = true
		}
	}

	return out
}

// Diff returns the set difference of this set with the provided set. The
// set difference of two sets A and B is defined as:
//	A \ B = {x | (x in A) and (x not in B)}
func (s *Uint8Set) Diff(s2 Uint8Set) *Uint8Set {
	out := NewUint8Set()

	for k := range s.vals {
		if !s2.vals[k] {
			out.vals[k] = true
		}
	}

	return out
}

// SymDiff returns the symmetric difference of this set with the provided set.
// The symmetric difference of two sets A and B is defined as:
//	A (+) B = {x | (x in A) xor (x in B)}
func (s *Uint8Set) SymDiff(s2 Uint8Set) *Uint8Set {
	out := NewUint8Set()

	for k := range s.vals {
		if !s2.vals[k] {
			out.vals[k] = true
		}
	}

	for k := range s2.vals {
		if !s.vals[k] {
			out.vals[k] = true
		}
	}

	return out
}

// StringSet implements the set data structure implemented with a map. The set
// has an optional capacity. By default, this cap is set to zero. Setting a
//positive cap will cause silent failures whenever trying to add elements to a
// full set.
type StringSet struct {
	vals map[string]bool
	cap  int
}

// NewStringSet creates a new set of string values.
func NewStringSet(vals ...string) *StringSet {
	s := StringSet{vals: map[string]bool{}}
	for _, v := range vals {
		s.vals[v] = true
	}
	return &s
}

func (s *StringSet) String() string {
	return fmt.Sprintf("%v", s.Enumerate())
}

// Contains checks if the provided value is in the set.
func (s *StringSet) Contains(val string) bool {
	return s.vals[val]
}

// IsSubset checks if the set is a subset of b i,e, every element of the set s
// is contained in b.
func (s *StringSet) IsSubset(b StringSet) bool {
	if len(s.vals) > len(b.vals) {
		return false
	}

	for k := range s.vals {
		if !b.vals[k] {
			return false
		}
	}

	return true
}

// IsEmpty checks of the set does not contain any elements.
func (s *StringSet) IsEmpty() bool {
	return len(s.vals) == 0
}

// Len returns the number of elements in the set.
func (s *StringSet) Len() int {
	return len(s.vals)
}

// Cap returns the capacity of the set.
func (s *StringSet) Cap() int {
	return s.cap
}

// SetCap sets the capacity of the set. If a negative integer is passed, then
// the capacity is set to 0. A capacity of 0 indicates no capacity.
func (s *StringSet) SetCap(c int) *StringSet {
	if c < 0 {
		c = 0
	}

	s.cap = c
	return s
}

// Enumerate returns a slice of the elements in the set that can be used in a
// for ... range loop. Depending on what the data is being used for, consider
// using the Map, Filter, and Fold methods instead as they act on the set
// itself.
func (s *StringSet) Enumerate() []string {
	keys := make([]string, len(s.vals))
	i := 0
	for k := range s.vals {
		keys[i] = k
		i++
	}
	return keys
}

// Add adds the provided val to the set. If the set has already reached
// capacity, then the addition silently fails.
func (s *StringSet) Add(val string) *StringSet {
	if s.cap > 0 && len(s.vals) == s.cap {
		return s
	}

	s.vals[val] = true
	return s
}

// Remove deletes the provided values from the set. If the value is not in the
// set, then this is a no-op.
func (s *StringSet) Remove(val string) *StringSet {
	delete(s.vals, val)
	return s
}

// Clear removes all elements from the set. This does not clear the capcity.
func (s *StringSet) Clear() *StringSet {
	for k := range s.vals {
		delete(s.vals, k)
	}
	return s
}

// Equals checks if the provided set is equal to this set. Sets A and B are
// equal if A is a subset of B and B is a subset of A.
func (s *StringSet) Equals(s2 StringSet) bool {
	if len(s.vals) != len(s2.vals) {
		return false
	}

	return s.IsSubset(s2)
}

// Map applies the provided function to every element in the set. Because the
// set must only contain unique elements, the size of the set may change
// after applying the transformation function.
func (s *StringSet) Map(f func(string) string) *StringSet {
	out := NewStringSet().SetCap(s.cap)
	for k := range s.vals {
		out.vals[f(k)] = true
	}
	return out
}

// Filter applies the provided function to every element in the set. The
// resulting set contains only the elements that caused the function to
// return true.
func (s *StringSet) Filter(f func(string) bool) *StringSet {
	out := NewStringSet().SetCap(s.cap)
	for k := range s.vals {
		if f(k) {
			out.vals[k] = true
		}
	}
	return out
}

// Fold reduces the set to a single value by successively applying the provided
// function to elements of the set beginning with the base. The operation
// performed in the provided function must be associative and communitive to
// guarantee a deterministic result.
func (s *StringSet) Fold(base string, f func(string, string) string) string {
	for k := range s.vals {
		base = f(base, k)
	}
	return base
}

// Union returns the union of this set with the provided set. The union of two
// sets A and B is defined by:
//	A union B = {x | (x in A) or (x in B)}
func (s *StringSet) Union(s2 StringSet) *StringSet {
	out := NewStringSet()

	for k := range s.vals {
		out.vals[k] = true
	}

	for k := range s2.vals {
		out.vals[k] = true
	}

	return out
}

// Intersect returns the intersection of this set with the provided set. The
// intersection of two sets A and B is defined by:
//	A intersect B = {x | (x in A) and (x in B)}
func (s *StringSet) Intersect(s2 StringSet) *StringSet {
	out := NewStringSet()

	for k := range s.vals {
		if s2.vals[k] {
			out.vals[k] = true
		}
	}

	for k := range s2.vals {
		if s.vals[k] {
			out.vals[k] = true
		}
	}

	return out
}

// Diff returns the set difference of this set with the provided set. The
// set difference of two sets A and B is defined as:
//	A \ B = {x | (x in A) and (x not in B)}
func (s *StringSet) Diff(s2 StringSet) *StringSet {
	out := NewStringSet()

	for k := range s.vals {
		if !s2.vals[k] {
			out.vals[k] = true
		}
	}

	return out
}

// SymDiff returns the symmetric difference of this set with the provided set.
// The symmetric difference of two sets A and B is defined as:
//	A (+) B = {x | (x in A) xor (x in B)}
func (s *StringSet) SymDiff(s2 StringSet) *StringSet {
	out := NewStringSet()

	for k := range s.vals {
		if !s2.vals[k] {
			out.vals[k] = true
		}
	}

	for k := range s2.vals {
		if !s.vals[k] {
			out.vals[k] = true
		}
	}

	return out
}

// RuneSet implements the set data structure implemented with a map. The set
// has an optional capacity. By default, this cap is set to zero. Setting a
//positive cap will cause silent failures whenever trying to add elements to a
// full set.
type RuneSet struct {
	vals map[rune]bool
	cap  int
}

// NewRuneSet creates a new set of rune values.
func NewRuneSet(vals ...rune) *RuneSet {
	s := RuneSet{vals: map[rune]bool{}}
	for _, v := range vals {
		s.vals[v] = true
	}
	return &s
}

func (s *RuneSet) String() string {
	return fmt.Sprintf("%v", s.Enumerate())
}

// Contains checks if the provided value is in the set.
func (s *RuneSet) Contains(val rune) bool {
	return s.vals[val]
}

// IsSubset checks if the set is a subset of b i,e, every element of the set s
// is contained in b.
func (s *RuneSet) IsSubset(b RuneSet) bool {
	if len(s.vals) > len(b.vals) {
		return false
	}

	for k := range s.vals {
		if !b.vals[k] {
			return false
		}
	}

	return true
}

// IsEmpty checks of the set does not contain any elements.
func (s *RuneSet) IsEmpty() bool {
	return len(s.vals) == 0
}

// Len returns the number of elements in the set.
func (s *RuneSet) Len() int {
	return len(s.vals)
}

// Cap returns the capacity of the set.
func (s *RuneSet) Cap() int {
	return s.cap
}

// SetCap sets the capacity of the set. If a negative integer is passed, then
// the capacity is set to 0. A capacity of 0 indicates no capacity.
func (s *RuneSet) SetCap(c int) *RuneSet {
	if c < 0 {
		c = 0
	}

	s.cap = c
	return s
}

// Enumerate returns a slice of the elements in the set that can be used in a
// for ... range loop. Depending on what the data is being used for, consider
// using the Map, Filter, and Fold methods instead as they act on the set
// itself.
func (s *RuneSet) Enumerate() []rune {
	keys := make([]rune, len(s.vals))
	i := 0
	for k := range s.vals {
		keys[i] = k
		i++
	}
	return keys
}

// Add adds the provided val to the set. If the set has already reached
// capacity, then the addition silently fails.
func (s *RuneSet) Add(val rune) *RuneSet {
	if s.cap > 0 && len(s.vals) == s.cap {
		return s
	}

	s.vals[val] = true
	return s
}

// Remove deletes the provided values from the set. If the value is not in the
// set, then this is a no-op.
func (s *RuneSet) Remove(val rune) *RuneSet {
	delete(s.vals, val)
	return s
}

// Clear removes all elements from the set. This does not clear the capcity.
func (s *RuneSet) Clear() *RuneSet {
	for k := range s.vals {
		delete(s.vals, k)
	}
	return s
}

// Equals checks if the provided set is equal to this set. Sets A and B are
// equal if A is a subset of B and B is a subset of A.
func (s *RuneSet) Equals(s2 RuneSet) bool {
	if len(s.vals) != len(s2.vals) {
		return false
	}

	return s.IsSubset(s2)
}

// Map applies the provided function to every element in the set. Because the
// set must only contain unique elements, the size of the set may change
// after applying the transformation function.
func (s *RuneSet) Map(f func(rune) rune) *RuneSet {
	out := NewRuneSet().SetCap(s.cap)
	for k := range s.vals {
		out.vals[f(k)] = true
	}
	return out
}

// Filter applies the provided function to every element in the set. The
// resulting set contains only the elements that caused the function to
// return true.
func (s *RuneSet) Filter(f func(rune) bool) *RuneSet {
	out := NewRuneSet().SetCap(s.cap)
	for k := range s.vals {
		if f(k) {
			out.vals[k] = true
		}
	}
	return out
}

// Fold reduces the set to a single value by successively applying the provided
// function to elements of the set beginning with the base. The operation
// performed in the provided function must be associative and communitive to
// guarantee a deterministic result.
func (s *RuneSet) Fold(base rune, f func(rune, rune) rune) rune {
	for k := range s.vals {
		base = f(base, k)
	}
	return base
}

// Union returns the union of this set with the provided set. The union of two
// sets A and B is defined by:
//	A union B = {x | (x in A) or (x in B)}
func (s *RuneSet) Union(s2 RuneSet) *RuneSet {
	out := NewRuneSet()

	for k := range s.vals {
		out.vals[k] = true
	}

	for k := range s2.vals {
		out.vals[k] = true
	}

	return out
}

// Intersect returns the intersection of this set with the provided set. The
// intersection of two sets A and B is defined by:
//	A intersect B = {x | (x in A) and (x in B)}
func (s *RuneSet) Intersect(s2 RuneSet) *RuneSet {
	out := NewRuneSet()

	for k := range s.vals {
		if s2.vals[k] {
			out.vals[k] = true
		}
	}

	for k := range s2.vals {
		if s.vals[k] {
			out.vals[k] = true
		}
	}

	return out
}

// Diff returns the set difference of this set with the provided set. The
// set difference of two sets A and B is defined as:
//	A \ B = {x | (x in A) and (x not in B)}
func (s *RuneSet) Diff(s2 RuneSet) *RuneSet {
	out := NewRuneSet()

	for k := range s.vals {
		if !s2.vals[k] {
			out.vals[k] = true
		}
	}

	return out
}

// SymDiff returns the symmetric difference of this set with the provided set.
// The symmetric difference of two sets A and B is defined as:
//	A (+) B = {x | (x in A) xor (x in B)}
func (s *RuneSet) SymDiff(s2 RuneSet) *RuneSet {
	out := NewRuneSet()

	for k := range s.vals {
		if !s2.vals[k] {
			out.vals[k] = true
		}
	}

	for k := range s2.vals {
		if !s.vals[k] {
			out.vals[k] = true
		}
	}

	return out
}
