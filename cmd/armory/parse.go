package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io/ioutil"
	"log"
	"regexp"
	"strings"
)

var (
	genericDSExpr   *regexp.Regexp
	genericTypeExpr *regexp.Regexp = regexp.MustCompile(`^Generic$`)
)

func parse(filename string) {
	genericDSExpr = regexp.MustCompile("Generic" + dataStructure)
	genericTypeExpr = regexp.MustCompile(`^Generic$`)

	fset := token.NewFileSet()
	af, err := parser.ParseFile(fset, "", MustAsset(filename), 0)
	if err != nil {
		log.Fatal(err)
	}

	af.Name.Name = pkgName

	newDecls := []ast.Decl{}
	for _, d := range af.Decls {
		if v, ok := d.(*ast.GenDecl); ok {
			if v.Tok == token.TYPE && v.Specs[0].(*ast.TypeSpec).Name.Name == "Generic" {
				continue
			}
		}

		ast.Walk(visitFunc(walk), d)
		newDecls = append(newDecls, d)
	}

	af.Decls = newDecls

	var out bytes.Buffer
	if err := format.Node(&out, fset, af); err != nil {
		log.Fatalf("format.Node: %v", err)
	}

	src := out.Bytes()

	src, err = format.Source(src)
	if err != nil {
		log.Fatalf("format.Source: %v on\n%s", err, src)
	}

	out.Reset()
	out.WriteString("// Code generated by armory; DO NOT EDIT.\n\n")

	out.Write(src)

	if outFile == "" {
		outFile = fmt.Sprintf("%s_%s.go", strings.ToLower(varType), strings.ToLower(dataStructure))
	}
	if err := ioutil.WriteFile(outFile, out.Bytes(), 0644); err != nil {
		log.Fatal(err)
	}
}

type visitFunc func(ast.Node) ast.Visitor

func (f visitFunc) Visit(n ast.Node) ast.Visitor { return f(n) }

func walk(n ast.Node) ast.Visitor {
	switch v := n.(type) {

	case *ast.Ident:
		v.Name = genericDSExpr.ReplaceAllString(v.Name, varTypeName+dataStructure)
		v.Name = genericTypeExpr.ReplaceAllString(v.Name, varType)

	}

	return visitFunc(walk)
}
