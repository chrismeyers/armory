package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io/ioutil"
	"log"
	"regexp"
	"strings"
)

var fset = token.NewFileSet()

var (
	varType     = "int"
	varTypeName = strings.Title(varType)
	ds          = "Set"
)

func parse() {
	af, err := parser.ParseFile(fset, "", MustAsset("set.go"), 0)
	if err != nil {
		log.Fatal(err)
	}

	af.Name.Name = "main"

	newDecls := []ast.Decl{}
	for _, d := range af.Decls {
		ast.Walk(visitFunc(walk), d)
		newDecls = append(newDecls, d)
	}

	af.Decls = newDecls

	var out bytes.Buffer
	if err := format.Node(&out, fset, af); err != nil {
		log.Fatalf("format.Node: %v", err)
	}

	src := out.Bytes()

	src, err = format.Source(src)
	if err != nil {
		log.Fatalf("format.Source: %v on\n%s", err, src)
	}

	out.Reset()
	out.WriteString("// Code generated by armory; DO NOT EDIT.\n\n")

	out.Write(src)

	target := fmt.Sprintf("%s%s.go", strings.ToLower(varType), strings.ToLower(ds))
	if err := ioutil.WriteFile(target, out.Bytes(), 0644); err != nil {
		log.Fatal(err)
	}
}

type visitFunc func(ast.Node) ast.Visitor

func (f visitFunc) Visit(n ast.Node) ast.Visitor { return f(n) }

func walk(n ast.Node) ast.Visitor {
	switch v := n.(type) {

	case *ast.Ident:
		v.Name = regexp.MustCompile(`GenericSet`).ReplaceAllString(v.Name, varTypeName+ds)
		v.Name = regexp.MustCompile(`^Generic$`).ReplaceAllString(v.Name, varType)

	}

	return visitFunc(walk)
}
