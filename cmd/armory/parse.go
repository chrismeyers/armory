package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io/ioutil"
	"log"
	"regexp"
	"strings"
)

var (
	genericDSExpr   *regexp.Regexp
	genericTypeExpr *regexp.Regexp
	zeroValExpr     *regexp.Regexp
)

func parse(filename string) {
	genericDSExpr = regexp.MustCompile("Generic" + dataStructure)
	genericTypeExpr = regexp.MustCompile(`^Generic$`)
	zeroValExpr = regexp.MustCompile(`^Zero$`)

	if zeroVal == "" {
		zeroVal = inferZero()
	}

	fset := token.NewFileSet()
	af, err := parser.ParseFile(fset, "", MustAsset(filename), 0)
	if err != nil {
		log.Fatal(err)
	}

	af.Name.Name = pkgName

	newDecls := []ast.Decl{}
	for _, d := range af.Decls {
		if v, ok := d.(*ast.GenDecl); ok {
			if v.Tok == token.TYPE && v.Specs[0].(*ast.TypeSpec).Name.Name == "Generic" {
				continue
			}

			if v.Tok == token.VAR && v.Specs[0].(*ast.ValueSpec).Names[0].Name == "Zero" {
				continue
			}
		}

		ast.Walk(visitFunc(walk), d)
		newDecls = append(newDecls, d)
	}

	af.Decls = newDecls

	var out bytes.Buffer
	if err := format.Node(&out, fset, af); err != nil {
		log.Fatalf("format.Node: %v", err)
	}

	src := out.Bytes()

	src, err = format.Source(src)
	if err != nil {
		log.Fatalf("format.Source: %v on\n%s", err, src)
	}

	out.Reset()
	out.WriteString("// Code generated by armory; DO NOT EDIT.\n\n")

	out.Write(src)

	if outFile == "" {
		outFile = fmt.Sprintf("%s_%s.go", strings.ToLower(varType), strings.ToLower(dataStructure))
	}
	if err := ioutil.WriteFile(outFile, out.Bytes(), 0644); err != nil {
		log.Fatal(err)
	}
}

func inferZero() string {
	switch varType {
	case "int", "int8", "int16", "int32", "int64":
		return "0"
	case "uint", "uint8", "uint16", "uint32", "uint64":
		return "0"
	case "float32", "float64":
		return "0"
	case "byte":
		return "0"
	case "complex64", "complex128":
		return "0 + 0i"
	case "string":
		return `""`
	case "rune":
		return "0"
	case "bool":
		return "false"
	}

	return "nil"
}

type visitFunc func(ast.Node) ast.Visitor

func (f visitFunc) Visit(n ast.Node) ast.Visitor { return f(n) }

func walk(n ast.Node) ast.Visitor {
	switch v := n.(type) {

	case *ast.Ident:
		v.Name = genericDSExpr.ReplaceAllString(v.Name, varTypeName+dataStructure)
		v.Name = genericTypeExpr.ReplaceAllString(v.Name, varType)
		v.Name = zeroValExpr.ReplaceAllString(v.Name, zeroVal)
	}

	return visitFunc(walk)
}
